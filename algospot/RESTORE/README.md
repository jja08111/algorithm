# 해결
이 문제는 크게 2가지의 단계로 나눠서 해결할 수 있다.

1. 문자열이 최대한 많이 겹치는 길이 구하기

2. 1번을 이용해 reconstruct하기


## 1. 문자열이 최대한 많이 겹치는 길이 구하기
이 부분에서도 2가지의 할일이 있다.

### 1. a가 b에 속하는 경우 a를 제외시킨다.

find()를 이용하여 string::npos가 아닌 위치를 반환 할 경우 문자가 속하는 것이다.

이를 이용하여 해당 위치의 값을 제거하고 범위도 한칸 줄인다.

### 2. 문자열들의 접미사와 접두사를 최대한 많이 겹치게 한다.

모든 문자들이 최대한 많이 겹치게 하는 overlap을 미리 구해 놓는다.(substr을 잘 활용하여야 한다.)

이전에 풀었던 TSP2와 같이 overlap의 합의 최대를 반환하도록 restore을 구현한다.


## 2. 1번을 이용해 reconstruct하기

최선의 선택을 배열에 저장해두지 않았으므로 직접 찾아야 한다.

next를 사용하였을때 답이 최적해와 같을때 next를 사용하여야 한다.


# 회고

코드를 설계하는 것 부터 엄청 어렵다.

구현하는것도 엄두가 안난다..
